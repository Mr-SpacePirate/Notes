# 0x23 $Redis$ 大 $key$ 对持久化有什么影响？

> $Redis$ 的持久化方式有两种：$AOF$ 日志和 $RDB$ 快照。

## 2.3.1 大 $key$ 对 $AOF$ 日志的影响

> 先说说 $AOF$ 日志三种写回磁盘的策略

$Redis$ 提供了 3 种 $AOF$ 日志写回硬盘的策略，分别是：

- **`Always`**：每次写操作执行完后，同步将 $AOF$ 日志数据写回硬盘；
- **`Everysec`**：每次写操作命令执行完后，先将命令写入到 $AOF$ 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回硬盘；
- **`No`**：不由 $Redis$ 控制协会硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 $AOF$ 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。

这三种策略只是在控制 `fsync()` 函数的调用时机。

当应用程序向文件写入数据时，内核通常先将数据复制到内核缓冲区中，然后排入队列，然后由内核决定何时写入硬盘。

![写回策略的实现](./../assets/0x20%20%E6%8C%81%E4%B9%85%E5%8C%96/%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5%E7%9A%84%E5%AE%9E%E7%8E%B0.webp)

如果想要应用程序向文件写入数据后，能立马将数据同步到硬盘，就可以调用 `fsync()` 函数，这样内核就会将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回。

- `Always` 策略就是每次写入 $AOF$ 文件数据后，就执行 `fsync()` 函数；
- `Everysec` 策略会创建一个异步任务来执行 `fsync()` 函数；
- `No` 策略就是用不执行 `fsync()` 函数；

> 分别说说这三种策略，在持久化大 key 的时候，会影响什么？

在使用 `Always` 策略的时候，主线程在执行完命令后，会把数据写入到 $AOF$ 日志文件，然后会调用 `fsync()` 函数，将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回。

**当使用 `Always` 策略的时候，如果写入是一个大 key，主线程在执行 `fsync()` 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的。**

当使用 `Everysec` 策略的时候，由于是异步执行 `fsync()` 函数，所以大 key 持久化的过程（数据同步磁盘）不会影响主线程。

当使用 `No` 策略的时候，由于用不执行 `fsync()` 函数，所以大 key 持久化的过程不会影响主线程。

## 2.3.2 大 $key$ 对 $AOF$ 重写和 $RDB$ 的影响

当 $AOF$ 日志写入了很多的大 key，$AOF$ 日志文件的大小会很大，那么很快就会触发 **$AOF$ 重写机制**。

$AOF$ 重写机制和 $RDB$ 快照（`bgsave` 命令）的过程，都会分别通过 `fork()` 函数创建一个子进程来处理任务。

在创建子进程的过程中，操作系统会把父进程的「页表」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。

![创建子进程时复制主进程页表](./../assets/0x20%20%E6%8C%81%E4%B9%85%E5%8C%96/%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%97%B6%E5%A4%8D%E5%88%B6%E4%B8%BB%E8%BF%9B%E7%A8%8B%E9%A1%B5%E8%A1%A8.webp)

这样一来，子进程就共享了父进程的物理内存数据了，这样能够**节约物理内存资源**，页表对应的页表项的属性会标记该物理内存的权限为**只读**。

随着 $Redis$ 存在越来越多的大 key，那么 $Redis$ 就会占用很多内存，对应的页表就会越大。

在通过 `fork()` 函数创建子进程的时候，虽然不会复制父进程的物理内存，但是**内核会把父进程的页表复制一份给子进程，如果页表很大，那么这个复制过程是会很耗时的，那么在执行 `fork` 函数的时候就会发生阻塞现象。**

而且，`fork` 函数是由 $Redis$ 主线程调用的，如果 `fork` 函数发生阻塞，那么意味着就会阻塞 $Redis$ 主线程。由于 $Redis$ 执行命令是在主线程处理的，所以当 $Redis$ 主线程发生阻塞，就无法处理后续客户端发来的命令。

我们可以执行 `info` 命令获取到 `latest_fork_usec` 指标，表示 $Redis$ 最近一次 `fork` 操作耗时。

``` conf
# 最近一次 fork 操作耗时
latest_fork_usec:315
```

如果 `fork` 耗时很大，比如超过 1 秒，则需要做出优化调整：

- 单个实例的内存占用控制在 $10GB$ 以下，这样 `fork` 函数就能很快返回。
- 如果 $Redis$ 只是当作纯缓存使用不关心 $Redis$ 数据安全性问题，可以考虑关闭 $AOF$ 重写，这样就不会调用 `fork` 函数了。
- 在主从框架中，要适当调大 `repl-backlog-size`，避免因为 `repl_backlog_buffer` 不够大，导致主节点频繁地使用全量同步的方式，全量同步的时候，是会创建 $RDB$ 文件的，也就是会调用 `fork` 函数。

> 那什么时候会发生物理内存的复制呢？

当父进程或者子进程在向共享内存发起写操作时，$CPU$ 就会触发**写保护中断**，这个「写保护中断」是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行物理内存的复制，并重新设置其内存映射关系，将





















