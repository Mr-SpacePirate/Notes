# 0x12 $Redis$ 数据结构

> **$Redis$ 为什么那么快？**
>
> 除了它是内存数据库，使得所有的操作都在内存上进行之外，还有一个重要因素，它实现的数据结构，使得我们对数据进行增删改查操作时，$Redis$ 能高效的处理。

注意，**$Redis$ 数据结构并不是 $String$（字符串）对象、$List$（列表）对象、$Hash$（哈希）对象、$Set$（集合）对象和 $Zset$（有序集合）对象，因为这些是 $Redis$ 键值对中值的数据类型，也就是数据的保存形式，这些对象的底层实现的方式就用到了数据结构。**

左边是 $Redis$ 3.0 版本的，也就是《Redis 设计与实现》这本书讲解的版本，现在看还是有点过时了，右边是现在 Github 最新的 $Redis$ 代码。

![Redis版本对比](./../assets/0x10%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Redis%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94.webp)

可以看到，$Redis$ 数据类型的底层数据结构随着版本的更新也有所不同，比如：

- 在 $Redis$ 3.0 版本中 $List$ 对象的底层数据结构由「双向链表」或「压缩表列表」实现，但是在 3.2 版本之后，$List$ 数据类型底层数据结构是由 $quicklist$ 实现的；
- 在最新的 $Redis$ 代码中，压缩列表数据结构已经被废弃了，交由$listpack$ 数据结构来实现了。

**新旧数据结构共有 $8$ 种：$SDS$、双向链表、压缩列表、哈希表、跳表、整数集合、$quicklist$、$listpack$**。

![数据结构](./../assets/0x10%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.webp)

## 1.2.1 键值对数据库是怎么实现的？

在开始讲数据结构之前，先介绍下 $Redis$ 时怎样实现键值对（key-value）数据库的。

$Redis$ 的键值对中的 key 就是字符串对象，而 **value 可以是字符串对象，也可以是集合数据类型的对象**，比如 $List$ 对象、$Hash$ 对象、$Set$ 对象和 $Zset$ 对象。

举个例子，我这里列出几种 $Redis$ 新增键值对的命令：

``` cmd
> SET name "jianghao"
OK

> HSET person name "jianghao" age 18
0

> RPUSH stu "jianghao" "lizhujin"
(integer) 4
```

这些命令代表着：

- 第一条命令：`name` 是一个**字符串键**，因为键的**值是一个字符串对象**；
- 第二条命令：`person` 是一个**哈希表键**，因为键的**值是一个包含两个键值对的哈希表对象**；
- 第三条命令：`stu` 是一个**列表键**，因为键的**值是一个包含两个元素的列表对象**；

这些键值对是如何保存在 $Redis$ 中的呢？

$Redis$ 是使用了一个「哈希表」保存所有键值对，哈希表的最大好处就是让我们可以用 $O(1)$ 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。

$Redis$ 的哈希桶是怎么保存键值对数据的呢？

哈希桶存放的是指向键值对数据的指针（`dictEntry*`)，这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据结构类型的对象，所以键值对数据结构中并不是直接保存值本身，而是保存了 `void* key` 和 `void* value` 指针，分别指向了实际的键对象和值对象，这样一来，即使值是几何数据，也可以通过 `void* value` 指针找到。

我这里画了一张 $Redis$ 保存键值对所涉及到的数据结构。

![键值对数据结构](./../assets/0x10%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E9%94%AE%E5%80%BC%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.webp)

这些数据结构的内部细节，在后面讲哈希表数据结构的时候，再详细说说，因为用到的数据结构是一样的。这里先大概说下图中涉及到的数据结构的名字和用途：

- $redisDb$ 结构，表示 $Redis$ 数据库的结构，结构体里存放了指向了 $dict$ 结构的指针；
- $dict$ 结构，结构体里存放了 $2$ 个哈希表，正常情况下都是用「哈希表1」、「哈希表2」只有在 $rehash$ 的时候才用，具体什么是 $rehash$，会在哈希表数据结构里讲；
- $dictht$ 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（$dictEntry$）的指针；
- $dictEntry$ 结构，表示哈希表节点的结构，结构里存放了 `void* key` 和 `void* value` 指针，**$key$ 指向的是 $String$ 对象，而 $value$ 则可以指向 $String$ 对象，也可以指向集合类型的对象，比如 $List$ 对象、$Hash$ 对象、$Set$ 对象和 $Zset$ 对象**。

特别说明下，`void* key` 和 `void* value` 指针指向的是 **$Redis$ 对象**，$Redis$ 中的每个对象都由 $redisObject$ 结构表示，如下图：

![redisObject结构](./../assets/0x10%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/redisObject%E7%BB%93%E6%9E%84.webp)

对象结构里包含的成员变量：

- `type`，标识该对象是什么类型的对象（$String$ 对象、$List$ 对象、$Hash$ 对象、$Set$ 对象和 $Zset$ 对象）；
- `encoding`，标识该对象使用了哪种底层的数据结构；
- **`ptr`，指向底层数据结构的指针**

![Redis对象和数据结构的关系](./../assets/0x10%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Redis%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB.webp)

## 1.2.2 $SDS$

> 字符串在 $Redis$ 中是很常用的，键值对中的键是字符串类型，值有时也是字符串类型。
>
> $Redis$ 是用 $C$ 语言实现的，但是它没有直接使用 $C$ 语言的 `char*` 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string, SDS）的数据结构来表示字符串，也就是 $Redis$ 的 $String$ 数据类型的底层数据结构是 $SDS$。
>
> 既然 $Redis$ 设计了 $SDS$ 结构来表示字符串，肯定是 $C$ 语言的 `char*` 字符数组存在一些缺陷。
>
> 要了解这一点，得先来看看 `char*` 字符数组的结构。

### $C$ 语言字符串的缺陷

$C$ 语言字符串其实就是一个字符数组，即数组中每个元素其实就是一个字符数组，即数组中每个元素是字符串中的一个字符。

比如，下图就是字符串"xiaolin"的 `char*` 字符数组的结构：

![xiaolin](./../assets/0x10%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/xiaolin.webp)

在 $C$ 语言里，对字符串操作时，`char*` 指针只是指向字符数组的起始位置，而**字符数组的结尾位置就用"\0"标识，意思是指字符串的结束。**

因此，$C$ 语言标准库中的字符串操作函数就通过判断字符串是不是 "\0" 来决定要不要停止操作，如果当前字符不是 "\0"，说明字符串还没结束，可以继续操作，如果当前字符是 "\0" 则说明字符串结束了，就要停止操作。

举个例子，$C$ 语言获取字符串长度的函数 `strlen`，就是通过字符数组中的每一个字符，并进行计数，等遇到字符为 "\0" 后，就会停止遍历，然后返回已经统计到的字符个数，几位字符串长度。下图显示了 `strlen` 函数的执行流程：

![strlen](./../assets/0x10%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/strlen.webp)

很明显，**$C$ 语言获取字符串长度的时间复杂度是 O(N)（这是一个可以改进的地方）**

$C$ 语言字符串用 "\0" 字符作为结尾标记有个缺陷。假设有个字符串中有个 "\0" 字符，这时在操作这个字符串时就会**提早结束**，比如 "xiao\0lin" 字符串，计算字符串长度的时候则会是 4，如下图：

![标记字符串](./../assets/0x10%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6%E4%B8%B2.webp)

因此，除了字符串的末尾之外，**字符串里面不能含有 "\0" 字符**，否则最先被程序读入的 "\0" 字符将被误认为是字符串结尾，这个限制使得 $C$ 语言的字符串只能保存文本数据，**不能保存像图片、音频、视频这样的二进制数据（这也是一个可以改进的地方）**

另外，$C$ 语言标准库中字符串的操作函数是很不安全的，对程序员很不友好，稍微一不注意，就会导致缓冲区溢出。

举个例子，`strcat` 函数是可以将两个字符串拼接在一起。

``` C
// 将 src 字符串拼接到 dest 字符串后面
char *strcat(char *dest, const char* src);
```

**$C$ 语言的字符串是不会记录自身的缓冲区大小的**，所以 `strcat` 函数假定程序员在执行这个函数时，已经为 `dest` 分配了足够多的内存，可以容纳 `src` 字符串中的所有内容，而**一旦这个假定不成立，就会发生缓冲区溢出，可能会造成程序运行中之，（这是一个可以改进的地方）**

而且，`strcat` 函数和 `strlen` 函数类似，时间复杂度也很高，也都需要先通过遍历字符串才能得到目标字符串的末尾。然后对于 `strcat` 函数来说，还要再遍历源字符串才能完成追加，**对字符串的操作效率不高**。

好了，通过以上分析，我们可以得知 $C$ 语言的字符串不足之处以及可以改进的地方：

- 获取字符串长度的时间复杂度为 $O(N)$
- 字符串的结尾是以 "\0" 字符表示，字符串里面不能包含有 "\0" 字符，因此不能保存二进制数据；
- 字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；

$Redis$ 实现的 $SDS$ 的结构就把上面这些问题解决了，接下来我们一起看看 $Redis$ 是如何解决的。



















